# app/api/routers/match.py
from fastapi import APIRouter, HTTPException, Depends, Query, status
from typing import List, Optional
from sqlalchemy.orm import Session
from datetime import datetime
import json

from app.db.models import Match, HeadToHead, TeamForm, MatchMarket
from app.database import get_db
from app.core.schemas import (
    MatchCreate, MatchUpdate, MatchResponse,
    HeadToHeadCreate, HeadToHeadResponse,
    TeamFormCreate, TeamFormResponse,
    MatchMarketCreate, MatchMarketResponse
)
from app.utils.logger import logger

router = APIRouter(tags=["matches"])

# ===== MATCH ENDPOINTS =====

@router.get("/test")
async def test_route():
    return {"message": "Matches router is working!"}

@router.post("/", response_model=MatchResponse, status_code=status.HTTP_201_CREATED)
async def create_match(
    match_data: MatchCreate,
    db: Session = Depends(get_db)
):
    """Create a new match."""
    try:
        match = Match(**match_data.dict())
        db.add(match)
        db.commit()
        db.refresh(match)
        logger.info(f"Created match {match.id}: {match.home_team} vs {match.away_team}")
        return match
    except Exception as e:
        db.rollback()
        logger.error(f"Error creating match: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@router.get("/", response_model=List[MatchResponse])
async def list_matches(
    skip: int = 0,
    limit: int = 100,
    league: Optional[str] = None,
    date_from: Optional[datetime] = None,
    date_to: Optional[datetime] = None,
    team_name: Optional[str] = None,
    db: Session = Depends(get_db)
):
    """List matches with filtering."""
    query = db.query(Match)
    
    if league:
        query = query.filter(Match.league.ilike(f"%{league}%"))
    
    if date_from:
        query = query.filter(Match.match_date >= date_from)
    
    if date_to:
        query = query.filter(Match.match_date <= date_to)
    
    if team_name:
        query = query.filter(
            (Match.home_team.ilike(f"%{team_name}%")) | 
            (Match.away_team.ilike(f"%{team_name}%"))
        )
    
    matches = query.order_by(Match.match_date.asc()).offset(skip).limit(limit).all()
    return matches

@router.get("/{match_id}", response_model=MatchResponse)
async def get_match(
    match_id: int,
    db: Session = Depends(get_db)
):
    """Get a specific match by ID."""
    match = db.query(Match).filter(Match.id == match_id).first()
    if not match:
        raise HTTPException(status_code=404, detail="Match not found")
    return match

@router.put("/{match_id}", response_model=MatchResponse)
async def update_match(
    match_id: int,
    match_data: MatchUpdate,
    db: Session = Depends(get_db)
):
    """Update a match."""
    match = db.query(Match).filter(Match.id == match_id).first()
    if not match:
        raise HTTPException(status_code=404, detail="Match not found")
    
    try:
        update_data = match_data.dict(exclude_unset=True)
        for field, value in update_data.items():
            setattr(match, field, value)
        
        match.updated_at = datetime.now()
        db.commit()
        db.refresh(match)
        logger.info(f"Updated match {match_id}")
        return match
    except Exception as e:
        db.rollback()
        logger.error(f"Error updating match {match_id}: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@router.delete("/{match_id}", status_code=status.HTTP_204_NO_CONTENT)
async def delete_match(
    match_id: int,
    db: Session = Depends(get_db)
):
    """Delete a match."""
    match = db.query(Match).filter(Match.id == match_id).first()
    if not match:
        raise HTTPException(status_code=404, detail="Match not found")
    
    try:
        db.delete(match)
        db.commit()
        logger.info(f"Deleted match {match_id}")
    except Exception as e:
        db.rollback()
        logger.error(f"Error deleting match {match_id}: {e}")
        raise HTTPException(status_code=500, detail=str(e))

# ===== HEAD-TO-HEAD ENDPOINTS =====

@router.post("/{match_id}/head-to-head", response_model=HeadToHeadResponse, status_code=status.HTTP_201_CREATED)
async def create_head_to_head(
    match_id: int,
    h2h_data: HeadToHeadCreate,
    db: Session = Depends(get_db)
):
    """Create head-to-head data for a match."""
    match = db.query(Match).filter(Match.id == match_id).first()
    if not match:
        raise HTTPException(status_code=404, detail="Match not found")
    
    try:
        h2h = HeadToHead(match_id=match_id, **h2h_data.dict())
        db.add(h2h)
        db.commit()
        db.refresh(h2h)
        logger.info(f"Created head-to-head for match {match_id}")
        return h2h
    except Exception as e:
        db.rollback()
        logger.error(f"Error creating head-to-head for match {match_id}: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@router.get("/{match_id}/head-to-head", response_model=HeadToHeadResponse)
async def get_head_to_head(
    match_id: int,
    db: Session = Depends(get_db)
):
    """Get head-to-head data for a match."""
    h2h = db.query(HeadToHead).filter(HeadToHead.match_id == match_id).first()
    if not h2h:
        raise HTTPException(status_code=404, detail="Head-to-head data not found")
    return h2h

# ===== TEAM FORM ENDPOINTS =====

@router.post("/{match_id}/team-form", response_model=TeamFormResponse, status_code=status.HTTP_201_CREATED)
async def create_team_form(
    match_id: int,
    form_data: TeamFormCreate,
    db: Session = Depends(get_db)
):
    """Create team form data for a match."""
    match = db.query(Match).filter(Match.id == match_id).first()
    if not match:
        raise HTTPException(status_code=404, detail="Match not found")
    
    try:
        form = TeamForm(match_id=match_id, **form_data.dict())
        db.add(form)
        db.commit()
        db.refresh(form)
        logger.info(f"Created team form for match {match_id}")
        return form
    except Exception as e:
        db.rollback()
        logger.error(f"Error creating team form for match {match_id}: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@router.get("/{match_id}/team-form", response_model=List[TeamFormResponse])
async def get_team_forms(
    match_id: int,
    team_type: Optional[str] = None,
    db: Session = Depends(get_db)
):
    """Get team form data for a match."""
    query = db.query(TeamForm).filter(TeamForm.match_id == match_id)
    
    if team_type:
        query = query.filter(TeamForm.team_type == team_type)
    
    forms = query.all()
    return forms

# ===== MATCH MARKET ENDPOINTS =====

@router.post("/{match_id}/markets", response_model=MatchMarketResponse, status_code=status.HTTP_201_CREATED)
async def add_market_to_match(
    match_id: int,
    market_data: MatchMarketCreate,
    db: Session = Depends(get_db)
):
    """Add a market to a match with odds."""
    match = db.query(Match).filter(Match.id == match_id).first()
    if not match:
        raise HTTPException(status_code=404, detail="Match not found")
    
    # Check if market already exists for this match
    existing = db.query(MatchMarket).filter(
        MatchMarket.match_id == match_id,
        MatchMarket.market_id == market_data.market_id
    ).first()
    
    if existing:
        raise HTTPException(status_code=400, detail="Market already added to this match")
    
    try:
        match_market = MatchMarket(match_id=match_id, **market_data.dict())
        db.add(match_market)
        db.commit()
        db.refresh(match_market)
        logger.info(f"Added market {market_data.market_id} to match {match_id}")
        return match_market
    except Exception as e:
        db.rollback()
        logger.error(f"Error adding market to match {match_id}: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@router.get("/{match_id}/markets", response_model=List[MatchMarketResponse])
async def get_match_markets(
    match_id: int,
    db: Session = Depends(get_db)
):
    """Get all markets for a match."""
    match = db.query(Match).filter(Match.id == match_id).first()
    if not match:
        raise HTTPException(status_code=404, detail="Match not found")
    
    markets = db.query(MatchMarket).filter(MatchMarket.match_id == match_id).all()
    return markets

@router.put("/{match_id}/markets/{market_id}", response_model=MatchMarketResponse)
async def update_match_market(
    match_id: int,
    market_id: int,
    market_data: MatchMarketCreate,
    db: Session = Depends(get_db)
):
    """Update market odds for a match."""
    match_market = db.query(MatchMarket).filter(
        MatchMarket.match_id == match_id,
        MatchMarket.market_id == market_id
    ).first()
    
    if not match_market:
        raise HTTPException(status_code=404, detail="Match market not found")
    
    try:
        update_data = market_data.dict(exclude_unset=True)
        for field, value in update_data.items():
            setattr(match_market, field, value)
        
        match_market.updated_at = datetime.now()
        db.commit()
        db.refresh(match_market)
        logger.info(f"Updated market {market_id} for match {match_id}")
        return match_market
    except Exception as e:
        db.rollback()
        logger.error(f"Error updating market {market_id} for match {match_id}: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@router.delete("/{match_id}/markets/{market_id}", status_code=status.HTTP_204_NO_CONTENT)
async def remove_market_from_match(
    match_id: int,
    market_id: int,
    db: Session = Depends(get_db)
):
    """Remove a market from a match."""
    match_market = db.query(MatchMarket).filter(
        MatchMarket.match_id == match_id,
        MatchMarket.market_id == market_id
    ).first()
    
    if not match_market:
        raise HTTPException(status_code=404, detail="Match market not found")
    
    try:
        db.delete(match_market)
        db.commit()
        logger.info(f"Removed market {market_id} from match {match_id}")
    except Exception as e:
        db.rollback()
        logger.error(f"Error removing market {market_id} from match {match_id}: {e}")
        raise HTTPException(status_code=500, detail=str(e))